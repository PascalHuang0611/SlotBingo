<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SlotBingo DEMO</title>
    <!-- BUG ä¿®æ­£ï¼šä¿®æ­£äº† tailwindcss çš„ç¶²å€ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700;900&display=swap');
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
            /* overflow: hidden; <-- å·²ç§»é™¤æ­¤è¡Œä»¥å…è¨±æ²å‹• */
        }
        .grid-cell {
            width: 60px;
            height: 60px;
            border: 2px solid #4a5568;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem; /* æ”¾å¤§è¡¨æƒ…ç¬¦è™Ÿ */
            font-weight: 900;
            border-radius: 8px;
            transition: all 0.2s ease-in-out;
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
        }
        .symbol-B { background: linear-gradient(145deg, #ef4444, #b91c1c); color: white; }
        .symbol-I { background: linear-gradient(145deg, #f97316, #c2410c); color: white; }
        .symbol-N { background: linear-gradient(145deg, #eab308, #a16207); color: white; }
        .symbol-G { background: linear-gradient(145deg, #22c55e, #15803d); color: white; }
        .symbol-O { background: linear-gradient(145deg, #3b82f6, #1d4ed8); color: white; }
        .symbol-SC { background: linear-gradient(145deg, #a855f7, #7e22ce); color: white; } /* SC çš„ä¸€èˆ¬èƒŒæ™¯ */
        .symbol-locked-sc { background: radial-gradient(circle, #fde047, #facc15, #eab308); color: #422006; }
        .symbol-empty { background-color: #2d3748; }
        
        /* ä¸­çé«˜äº®ç‰¹æ•ˆ */
        .winning-cell {
            border-color: #fde047;
            box-shadow: 0 0 15px #facc15;
            transform: scale(1.08);
        }

        .spin-animation { animation: spin-cell 0.25s ease-in-out; } /* æ™‚é–“æ¸›åŠ */
        @keyframes spin-cell {
            0% { transform: translateY(-20px) scale(0.8); opacity: 0; }
            50% { transform: translateY(10px); }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }

        /* FG Respin å‹•ç•« */
        .fg-spin-reel {
            position: absolute;
            top: 0; 
            left: 0; 
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            transition-property: transform; /* æŒ‡å®š transition çš„å±¬æ€§ */
            will-change: transform; /* å¹³æ»‘åº¦æå‡ */
        }
        
        /* æ¯å€‹ã€Œæ²å¸¶é …ç›®ã€å›ºå®š 60px é«˜ï¼Œä¸å†ä¾è³´ Tailwind çš„ h-[60px] */
        .fg-item {
          height: 60px;
          width: 100%; /* BUG ä¿®æ­£ï¼šç¢ºä¿èƒŒæ™¯è‰²å¡Šå¡«æ»¿å¯¬åº¦ */
          display: flex;
          align-items: center;
          justify-content: center;
        }

        .bingo-pattern {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 2px;
            width: 50px;
            height: 50px;
        }
        .bingo-pattern-cell {
            width: 100%;
            height: 100%;
            background-color: #4a5568;
        }
        .bingo-pattern-cell.active {
            background-color: #facc15;
        }
    </style>
</head>
<!-- BUG ä¿®æ­£ï¼šåœ¨ body å¢åŠ  pb-8 (padding-bottom) ä¾†é¿å…åº•éƒ¨æ¸²æŸ“éŒ¯èª¤ -->
<body class="flex flex-col items-center p-4 pb-8">

    <!-- åˆå§‹è¼‰å…¥ç•«é¢ -->
    <div id="loader-container" class="text-center py-20">
        <h1 class="text-4xl font-bold mb-4">SlotBingo DEMO</h1>
        <p class="text-gray-400 mb-8">è«‹è¼‰å…¥éŠæˆ²è¨­å®šæª”ä»¥é–‹å§‹</p>
        <input type="file" id="json-file-input" accept=".json" class="hidden">
        <button id="load-json-button" class="bg-blue-600 hover:bg-blue-500 text-white font-bold text-2xl py-3 px-12 rounded-full shadow-lg transition-transform transform hover:scale-105">
            è¼‰å…¥è¨­å®šæª” (config.json)
        </button>
        <p id="loader-error" class="text-red-400 mt-4 h-6"></p>
    </div>

    <!-- éŠæˆ²ä¸»ç•«é¢ (é è¨­éš±è—) -->
    <div id="game-container" class="w-full max-w-4xl mx-auto hidden">
        <!-- é ‚éƒ¨è³‡è¨Šæ¬„ -->
        <div id="info-header" class="mb-4 p-4 bg-gray-900/50 rounded-lg border border-gray-700 min-h-[180px]"></div>

        <!-- éŠæˆ²ä¸»ç›¤é¢ -->
        <div id="grid-container" class="grid grid-cols-5 gap-2 mx-auto w-fit mb-6 p-4 bg-gray-900/50 rounded-lg border border-gray-700">
            <!-- Cells will be generated by JS -->
        </div>

        <!-- æ§åˆ¶é …èˆ‡è¨Šæ¯ -->
        <div class="text-center">
            <div id="message-log" class="mb-2 text-lg h-8 font-bold text-yellow-300">æŒ‰ä¸‹ SPIN é–‹å§‹éŠæˆ²</div>
            <div id="win-details-log" class="mb-4 text-sm h-auto min-h-[6rem] text-gray-300 bg-black/20 p-2 rounded-md"></div>
            <div class="flex items-center justify-center gap-6">
                <button id="spin-button" class="bg-yellow-500 hover:bg-yellow-400 text-gray-900 font-bold text-2xl py-3 px-12 rounded-full shadow-lg transition-transform transform hover:scale-105 disabled:bg-gray-600 disabled:cursor-not-allowed">
                    SPIN
                </button>
                <label for="autospin-checkbox" class="flex items-center cursor-pointer select-none">
                    <input type="checkbox" id="autospin-checkbox" class="w-6 h-6 rounded text-yellow-500 bg-gray-700 border-gray-600 focus:ring-yellow-600">
                    <span class="ml-2 text-lg font-semibold text-gray-300">AUTOSPIN</span>
                </label>
            </div>
        </div>
    </div>

    <script>
    // --- è¼”åŠ©å‡½å¼ ---
    const sleep = ms => new Promise(res => setTimeout(res, ms));

    // --- éŠæˆ²é‚è¼¯é¡åˆ¥ (ç§»æ¤è‡ª C++) ---

    class BoardGenerator {
        constructor(weights) {
            this.all_reel_weights = weights;
            this.reel_symbols = [];
            this.reel_total_weights = [];

            for (let i = 0; i < 5; i++) {
                const reel_name = `reel_${i + 1}`;
                const reel_config = this.all_reel_weights[reel_name];
                const symbols = Object.keys(reel_config);
                this.reel_symbols.push(symbols);
                
                let total_weight = 0;
                const cumulative_weights = [];
                for (const symbol of symbols) {
                    total_weight += reel_config[symbol];
                    cumulative_weights.push({ symbol, weight: total_weight });
                }
                this.reel_total_weights.push({ total: total_weight, cumulative: cumulative_weights });
            }
        }

        chooseSymbol(reel_index) {
            const reel_data = this.reel_total_weights[reel_index];
            if (reel_data.total === 0) return "";
            const random_value = Math.floor(Math.random() * reel_data.total);
            
            for (const item of reel_data.cumulative) {
                if (random_value < item.weight) {
                    return item.symbol;
                }
            }
            return "";
        }

        generateBoard() {
            const board = Array(5).fill(null).map(() => Array(5).fill(""));
            for (let reel = 0; reel < 5; ++reel) {
                for (let row = 0; row < 5; ++row) {
                    board[row][reel] = this.chooseSymbol(reel);
                }
            }
            return board;
        }
    }

    class WayGameCalculator {
        constructor(pay_table) {
            this.pay_table = pay_table;
        }

        calculateScore(board) {
            const result = { total_win: 0, details: [] };
            const symbols_to_check = Object.keys(this.pay_table).filter(s => s !== "SC");

            for (const symbol of symbols_to_check) {
                const pays = this.pay_table[symbol];
                const counts_per_reel = [0, 0, 0, 0, 0];
                for (let reel = 0; reel < 5; ++reel) {
                    for (let row = 0; row < 5; ++row) {
                        if (board[row][reel] === symbol) counts_per_reel[reel]++;
                    }
                }

                if (counts_per_reel[0] === 0) continue;

                let current_ways = counts_per_reel[0];
                for (let reel = 1; reel < 5; ++reel) {
                    if (counts_per_reel[reel] > 0) {
                        current_ways *= counts_per_reel[reel];
                        const connect_count = reel + 1;
                        if (connect_count >= 3) {
                            const pay = pays[5 - connect_count];
                            if (pay > 0) {
                                result.details.push({ symbol, connect_count, ways: current_ways, single_win_amount: pay * current_ways });
                            }
                        }
                    } else {
                        break;
                    }
                }
            }
            
            const max_connect = {};
            result.details.forEach(detail => {
                if (!max_connect[detail.symbol] || detail.connect_count > max_connect[detail.symbol]) {
                    max_connect[detail.symbol] = detail.connect_count;
                }
            });

            const final_result = { total_win: 0, details: [] };
            result.details.forEach(detail => {
                if (detail.connect_count === max_connect[detail.symbol]) {
                    final_result.details.push(detail);
                    final_result.total_win += detail.single_win_amount;
                }
            });

            return final_result;
        }
    }

    class BingoChecker {
        constructor(prizes) {
            this.prizes = prizes;
            this.parsed_prizes = {};
            for(const name in prizes) {
                this.parsed_prizes[name] = {
                    payout: prizes[name].payout,
                    patterns: prizes[name].patterns.map(p => p.split(',').map(Number))
                }
            }
        }

        check(final_board) {
            const result = {};
            for (const name in this.parsed_prizes) {
                const prize = this.parsed_prizes[name];
                let win_count = 0;
                for (const pattern of prize.patterns) {
                    let pattern_matched = true;
                    for (const index of pattern) {
                        const row = Math.floor((index - 1) / 5);
                        const col = (index - 1) % 5;
                        if (final_board[row][col] !== "SC") {
                            pattern_matched = false;
                            break;
                        }
                    }
                    if (pattern_matched) win_count++;
                }
                if (win_count > 0) result[name] = win_count;
            }
            return result;
        }
    }

    // --- ä¸»éŠæˆ²æ§åˆ¶å™¨ ---
    class Game {
        constructor(config) {
            this.config = config;
            this.gameState = 'BASE_GAME'; // BASE_GAME, FREE_GAME, FG_ENDED
            this.FG_TRIGGER_COUNT = 8;
            this.isAutoSpin = false;

            this.boardGenerator = new BoardGenerator(config.reel_weights);
            this.wayGameCalculator = new WayGameCalculator(config.pay_table);
            this.bingoChecker = new BingoChecker(config.bingo_prizes);

            this.gridContainer = document.getElementById('grid-container');
            this.spinButton = document.getElementById('spin-button');
            this.messageLog = document.getElementById('message-log');
            this.winDetailsLog = document.getElementById('win-details-log');
            this.infoHeader = document.getElementById('info-header');
            this.autoSpinCheckbox = document.getElementById('autospin-checkbox');

            this.init();
        }

        init() {
            this.renderInitialBoard();
            this.updateInfoHeader();
            this.spinButton.addEventListener('click', () => this.handleButtonClick());
            this.autoSpinCheckbox.addEventListener('change', () => this.toggleAutoSpin());
        }
        
        toggleAutoSpin() {
            this.isAutoSpin = this.autoSpinCheckbox.checked;
            if (this.isAutoSpin && this.gameState === 'BASE_GAME' && !this.spinButton.disabled) {
                this.runSingleRound();
            }
        }

        handleButtonClick() {
            if (this.gameState === 'BASE_GAME') {
                if (this.isAutoSpin) { // ç›®å‰åœ¨è‡ªå‹• â†’ é» SPIN åªåšã€Œåœæ­¢ã€
                    this.isAutoSpin = false;
                    this.autoSpinCheckbox.checked = false;
                    this.logMessage("Autospin å·²åœæ­¢");
                    return;
                }
                this.runSingleRound();
            } else if (this.gameState === 'FG_ENDED') {
                this.endFreeGame();
            }
        }

        renderInitialBoard() {
            this.gridContainer.innerHTML = '';
            for (let i = 0; i < 25; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell symbol-empty';
                cell.textContent = '?';
                this.gridContainer.appendChild(cell);
            }
        }
        
        createBingoPatternHTML(pattern) {
            let html = '<div class="bingo-pattern">';
            const activeCells = pattern.split(',').map(Number);
            for (let i = 1; i <= 25; i++) {
                html += `<div class="bingo-pattern-cell ${activeCells.includes(i) ? 'active' : ''}"></div>`;
            }
            html += '</div>';
            return html;
        }

        updateInfoHeader() {
            let html = '';
            if (this.gameState === 'BASE_GAME' || this.gameState === 'FG_ENDED') {
                html = `<div class="flex justify-between items-start gap-4">
                    <!-- Way Game è³ ç‡ -->
                    <div class="w-1/2">
                        <h2 class="text-center text-xl font-bold text-yellow-300 mb-2">WAY GAME è³ ç‡</h2>
                        <div class="space-y-1 text-sm">`;
                const symbols = ['B', 'I', 'N', 'G', 'O'];
                symbols.forEach(s => {
                    const pays = this.config.pay_table[s];
                    html += `<div class="flex items-center justify-between p-1 bg-gray-800 rounded">
                                <div class="flex items-center gap-2">
                                    <div class="w-6 h-6 rounded-sm flex items-center justify-center font-black symbol-${s}">${s}</div>
                                    <span>5x: ${pays[0]}</span>
                                    <span>4x: ${pays[1]}</span>
                                    <span>3x: ${pays[2]}</span>
                                </div>
                             </div>`;
                });
                html += `</div></div>
                    <!-- SCATTER æ”¶é›†çå‹µ -->
                    <div class="w-1/2">
                         <h2 class="text-center text-xl font-bold text-yellow-300 mb-2">SCATTER æ”¶é›†çå‹µ</h2>
                         <div class="space-y-1">`;
                for(const count in this.config.scatter_pays) {
                     html += `<div class="flex items-center justify-between p-2 bg-gray-800 rounded">
                        <span class="font-bold text-lg text-yellow-400">${count}+ ğŸ˜‰</span>
                        <span class="text-md font-semibold">${this.config.scatter_pays[count]} å€</span>
                    </div>`;
                }
                html += `</div></div></div>`;
            } else { // FREE_GAME
                html = `<div class="flex justify-between items-start gap-4">
                    <!-- BINGO çå‹µ -->
                    <div class="w-1/2">
                        <h2 class="text-center text-xl font-bold text-yellow-300 mb-2">BINGO åœ–æ¡ˆçå‹µ</h2>
                        <div class="space-y-1">`;
                const prize_order = ["Grand", "Mega", "Major", "Minor", "Mini"];
                for(const name of prize_order) {
                    const prize = this.config.bingo_prizes[name];
                    html += `<div class="flex items-center justify-between p-1 bg-gray-800 rounded">
                        <div class="flex items-center gap-2">
                            ${this.createBingoPatternHTML(prize.patterns[0])}
                            <span class="font-bold text-lg text-yellow-400">${name}</span>
                        </div>
                        <span class="text-md font-semibold">${prize.payout} å€</span>
                    </div>`;
                }
                html += `</div></div>
                    <!-- SCATTER æ”¶é›†çå‹µ -->
                    <div class="w-1/2">
                         <h2 class="text-center text-xl font-bold text-yellow-300 mb-2">SCATTER æ”¶é›†çå‹µ</h2>
                         <div class="space-y-1">`;
                for(const count in this.config.scatter_pays) {
                     html += `<div class="flex items-center justify-between p-2 bg-gray-800 rounded">
                        <span class="font-bold text-lg text-yellow-400">${count}+ ğŸ˜‰</span>
                        <span class="text-md font-semibold">${this.config.scatter_pays[count]} å€</span>
                    </div>`;
                }
                html += `</div></div></div>`;
            }
            this.infoHeader.innerHTML = html;
        }
        
        async animateSpin() {
            const cells = this.gridContainer.children;
            const symbols = ['B','I','N','G','O','SC'];
            for (let i = 0; i < 5; i++) { // æ™‚é–“æ¸›åŠ
                for (const cell of cells) {
                    const randomSymbol = symbols[Math.floor(Math.random() * symbols.length)];
                    cell.textContent = randomSymbol === 'SC' ? 'ğŸ˜‰' : randomSymbol;
                    cell.className = `grid-cell symbol-${randomSymbol}`;
                }
                await sleep(50);
            }
        }

        renderBoard(board, winningCells = []) {
             const cells = this.gridContainer.children;
             const winningSet = new Set(winningCells.map(pos => `${pos[0]}-${pos[1]}`));
             for (let r = 0; r < 5; r++) {
                for (let c = 0; c < 5; c++) {
                    const cell = cells[r * 5 + c];
                    const symbol = board[r][c];
                    cell.textContent = symbol === 'SC' ? 'ğŸ˜‰' : symbol;
                    let classes = `grid-cell symbol-${symbol} spin-animation`;
                    if (winningSet.has(`${r}-${c}`)) {
                        classes += ' winning-cell';
                    }
                    cell.className = classes;
                }
            }
        }

        logMessage(msg, isJackpot = false) {
            this.messageLog.textContent = msg;
            this.messageLog.className = isJackpot ? 'mb-2 text-2xl h-8 font-bold text-yellow-200 animate-pulse' : 'mb-2 text-lg h-8 font-bold text-yellow-300';
        }

        async runSingleRound() {
            this.spinButton.disabled = true;
            this.autoSpinCheckbox.disabled = true;
            this.winDetailsLog.innerHTML = '';
            this.logMessage("è½‰å‹•ä¸­...");
            await this.animateSpin();

            const board = this.boardGenerator.generateBoard();
            
            let total_win = 0;
            let scatter_count = 0;
            board.flat().forEach(s => { if (s === 'SC') scatter_count++; });

            const scatter_pays = Object.entries(this.config.scatter_pays).sort((a,b) => b[0] - a[0]);
            let scatter_win = 0;
            for(const [count, pay] of scatter_pays) {
                if (scatter_count >= parseInt(count)) {
                    scatter_win = pay;
                    break;
                }
            }
            
            const way_game_result = this.wayGameCalculator.calculateScore(board);
            total_win = scatter_win + way_game_result.total_win;
            
            const winningCells = [];
            if (scatter_win > 0) {
                for(let r=0; r<5; r++) for(let c=0; c<5; c++) if(board[r][c] === 'SC') winningCells.push([r,c]);
            }
            if (way_game_result.total_win > 0) {
                way_game_result.details.forEach(d => {
                    for(let c=0; c < d.connect_count; c++) {
                        for(let r=0; r < 5; r++) {
                            if(board[r][c] === d.symbol) winningCells.push([r,c]);
                        }
                    }
                });
            }

            this.renderBoard(board, winningCells);

            let detailsHtml = '';
            if (scatter_win > 0) {
                detailsHtml += `<div>ğŸ˜‰ å¾—åˆ†: ${scatter_count} å€‹, è´åˆ†: ${scatter_win.toFixed(2)}</div>`;
            }
            if (way_game_result.total_win > 0) {
                way_game_result.details.forEach(d => {
                    detailsHtml += `<div>ç¬¦è™Ÿ: ${d.symbol}, é€£ç·š: ${d.connect_count}, è·¯å¾‘æ•¸: ${d.ways}, è´åˆ†: ${d.single_win_amount.toFixed(2)}</div>`;
                });
            }
            this.winDetailsLog.innerHTML = detailsHtml;

            if (total_win > 0) {
                this.logMessage(`ä¸»éŠæˆ²è´å¾— ${total_win.toFixed(2)} å€!`);
            } else {
                this.logMessage("æœªä¸­ç");
            }

            if (scatter_count >= this.FG_TRIGGER_COUNT) {
                this.isAutoSpin = false;
                this.autoSpinCheckbox.checked = false;
                this.logMessage(`æ­å–œï¼ ${scatter_count} å€‹ ğŸ˜‰ï¼Œé€²å…¥å…è²»éŠæˆ²ï¼`, true);
                await sleep(1000); // æ™‚é–“æ¸›åŠ
                await this.runFreeGame(board);
            } else {
                if (this.isAutoSpin) {
                    await sleep(750); // æ™‚é–“æ¸›åŠ
                    if (this.isAutoSpin) {
                        this.runSingleRound();
                    } else {
                        this.spinButton.disabled = false;
                        this.autoSpinCheckbox.disabled = false;
                    }
                } else {
                    this.spinButton.disabled = false;
                    this.autoSpinCheckbox.disabled = false;
                }
            }
        }
        
        endFreeGame() {
            this.gameState = 'BASE_GAME';
            this.updateInfoHeader();
            this.renderInitialBoard();
            this.logMessage("è«‹æŒ‰ä¸‹ SPIN é–‹å§‹æ–°ä¸€å›åˆ");
            this.winDetailsLog.innerHTML = '';
            this.spinButton.textContent = 'SPIN';
            this.spinButton.disabled = false;
            this.autoSpinCheckbox.disabled = false;
            if (this.isAutoSpin) {
                this.runSingleRound();
            }
        }

        async runFreeGame(trigger_board) {
            this.gameState = 'FREE_GAME';
            this.updateInfoHeader();
            this.logMessage("å…è²»éŠæˆ²é–‹å§‹ï¼", true);
            this.winDetailsLog.innerHTML = '';

            const fg_board = Array(5).fill(null).map(() => Array(5).fill(null));
            let current_scatters = 0;
            for(let r=0; r<5; ++r) {
                for(let c=0; c<5; ++c) {
                    if(trigger_board[r][c] === 'SC') {
                        fg_board[r][c] = 'SC';
                        current_scatters++;
                    }
                }
            }

            let respins = 3;
            while(respins > 0) {
                this.logMessage(`å‰©é¤˜ ${respins} æ¬¡ | ç›®å‰ ${current_scatters} å€‹ ğŸ˜‰`);
                
                const respin_board = this.boardGenerator.generateBoard();
                
                const cells = this.gridContainer.children;
                const symbols = ['B','I','N','G','O'];
                const STAGGER_PER_COL_MS = 60; // æ™‚é–“æ¸›åŠ
                const STAGGER_PER_ROW_MS = 0;
                const BASE_TRANSITION_MS = 600; // æ™‚é–“æ¸›åŠ

                for (let i = 0; i < cells.length; i++) {
                    const r = Math.floor(i / 5);
                    const c = i % 5;
                    const cell = cells[i];
                    cell.innerHTML = '';
                    
                    if (fg_board[r][c] === 'SC') {
                        cell.textContent = 'ğŸ˜‰';
                        cell.className = 'grid-cell symbol-locked-sc';
                    } else {
                        cell.className = 'grid-cell symbol-empty';
                        const final_symbol = respin_board[r][c];
                        const reelContent = [final_symbol, ...symbols, ...symbols].map(s => 
                            `<div class="fg-item symbol-${s}">${s === 'SC' ? 'ğŸ˜‰' : s}</div>`
                        ).join('');
                        
                        const reelDiv = document.createElement('div');
                        reelDiv.className = 'fg-spin-reel';
                        reelDiv.innerHTML = reelContent;
                        
                        const delayMs = (c * STAGGER_PER_COL_MS) + (r * STAGGER_PER_ROW_MS);
                        reelDiv.style.transitionDelay = `${delayMs}ms`;
                        reelDiv.style.transitionDuration = `${BASE_TRANSITION_MS}ms`;
                        reelDiv.style.transform = `translateY(-${(symbols.length * 2) * 60}px)`;

                        cell.appendChild(reelDiv);
                        
                        requestAnimationFrame(() => {
                            void reelDiv.offsetWidth; 
                            reelDiv.style.transform = 'translateY(0)';
                        });
                    }
                }
                
                const maxDelay = (4 * STAGGER_PER_COL_MS) + (4 * STAGGER_PER_ROW_MS);
                await sleep(BASE_TRANSITION_MS + maxDelay + 60); // æ™‚é–“æ¸›åŠ

                let new_sc_landed = false;
                const newlyLandedCells = [];
                for (let r = 0; r < 5; r++) {
                    for (let c = 0; c < 5; c++) {
                        if (!fg_board[r][c] && respin_board[r][c] === 'SC') {
                            fg_board[r][c] = 'SC';
                            current_scatters++;
                            new_sc_landed = true;
                            newlyLandedCells.push([r,c]);
                        }
                    }
                }

                const winningSet = new Set(newlyLandedCells.map(pos => `${pos[0]}-${pos[1]}`));
                for (let i = 0; i < cells.length; i++) {
                    const r = Math.floor(i / 5);
                    const c = i % 5;
                    const cell = cells[i];
                    cell.innerHTML = ''; 
                    const finalSymbol = fg_board[r][c] || respin_board[r][c];
                    cell.textContent = finalSymbol === 'SC' ? 'ğŸ˜‰' : finalSymbol;
                    cell.className = `grid-cell symbol-${finalSymbol || 'empty'}`;
                    if (winningSet.has(`${r}-${c}`)) {
                        cell.classList.add('winning-cell');
                    } else if (fg_board[r][c] === 'SC') {
                        cell.classList.add('symbol-locked-sc');
                    }
                }

                if (new_sc_landed) {
                    respins = 3;
                } else {
                    respins--;
                }
                
                await sleep(500); // æ™‚é–“æ¸›åŠ

                if (current_scatters === 25) {
                    this.logMessage(`æ­å–œï¼å…¨ç›¤ ğŸ˜‰ï¼`, true);
                    break;
                }
            }
            
            // æœ€çµ‚çµç®—
            const cells = this.gridContainer.children;
             for (let r = 0; r < 5; r++) {
                for (let c = 0; c < 5; c++) {
                    const cell = cells[r * 5 + c];
                    cell.innerHTML = ''; // æ¸…ç©ºå‹•ç•«
                    if (fg_board[r][c] === 'SC') {
                        cell.textContent = 'ğŸ˜‰';
                        cell.className = 'grid-cell symbol-locked-sc winning-cell';
                    } else {
                        cell.textContent = '';
                        cell.className = 'grid-cell symbol-empty';
                    }
                }
            }

            let fg_total_win = 0;
            let detailsHtml = '';
            
            const scatter_pays = Object.entries(this.config.scatter_pays).sort((a,b) => b[0] - a[0]);
            let scatter_win = 0;
            for(const [count, pay] of scatter_pays) {
                if (current_scatters >= parseInt(count)) {
                    scatter_win = pay;
                    break;
                }
            }
             if (scatter_win > 0) {
                detailsHtml += `<div>ğŸ˜‰ æ•¸é‡çé‡‘ (${current_scatters} å€‹): ${scatter_win.toFixed(2)}</div>`;
                fg_total_win += scatter_win;
            }


            const bingo_result = this.bingoChecker.check(fg_board);
            const prize_order = ["Grand", "Mega", "Major", "Minor", "Mini"];
            for(const name of prize_order) {
                if(bingo_result[name]) {
                    const win_count = bingo_result[name];
                    const payout = this.config.bingo_prizes[name].payout;
                    const bingo_win = payout * win_count;
                    detailsHtml += `<div>${name} ç x ${win_count}, è´åˆ†: ${bingo_win.toFixed(2)}</div>`;
                    fg_total_win += bingo_win;
                }
            }
            this.winDetailsLog.innerHTML = detailsHtml;

            this.logMessage(`å…è²»éŠæˆ²ç¸½è´åˆ†: ${fg_total_win.toFixed(2)} å€!`, true);
            
            // é€²å…¥ FG çµæŸç­‰å¾…ç‹€æ…‹
            this.gameState = 'FG_ENDED';
            this.spinButton.textContent = 'çµæŸ FG';
            this.spinButton.disabled = false;
        }
    }

    // --- å•Ÿå‹•éŠæˆ² ---
    document.addEventListener('DOMContentLoaded', () => {
        const loadButton = document.getElementById('load-json-button');
        const fileInput = document.getElementById('json-file-input');
        const loaderContainer = document.getElementById('loader-container');
        const gameContainer = document.getElementById('game-container');
        const loaderError = document.getElementById('loader-error');

        loadButton.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const config = JSON.parse(e.target.result);
                    // ç°¡å–®é©—è­‰ä¸€ä¸‹ config æª”æ¡ˆçš„çµæ§‹
                    if (config.game_settings && config.pay_table && config.reel_weights) {
                        loaderError.textContent = '';
                        loaderContainer.classList.add('hidden');
                        gameContainer.classList.remove('hidden');
                        new Game(config);
                    } else {
                        throw new Error('JSON æª”æ¡ˆç¼ºå°‘å¿…è¦çš„è¨­å®šéµã€‚');
                    }
                } catch (error) {
                    loaderError.textContent = `éŒ¯èª¤: ${error.message}`;
                }
            };
            reader.onerror = () => {
                loaderError.textContent = 'è®€å–æª”æ¡ˆæ™‚ç™¼ç”ŸéŒ¯èª¤ã€‚';
            };
            reader.readAsText(file);
        });
    });
    </script>

</body>
</html>
